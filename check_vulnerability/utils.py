import time
import requests as s

from selenium import webdriver

from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from selenium.common.exceptions import TimeoutException


def is_vulnerable(response):
    errors = [
        # Flask
        'syntaxerror:',
        # MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        # SQL Server
        "unclosed quotation mark after the character string",
        # Oracle
        "quoted string not properly terminated",
    ]
    for error in errors:
        if error in response.content.decode().lower():
            return True
    return False


def scan_sql_injection(url):
    injection_case = ["\"", "'"]
    for c in injection_case:
        new_url = f"{url}{c}"
        res = s.get(new_url)
        if is_vulnerable(res):
            return new_url


class SeleniumXSS:
    has_alert = False

    def __init__(self, url, headless=False):
        self.url = url
        self.driver = self._get_driver(headless)

    def _get_driver(self, headless):
        # import ipdb; ipdb.set_trace()
        from django.conf import settings
        import os
        chrome_path = os.path.join(settings.BASE_DIR, 'chromedriver')
        print(chrome_path)
        chrome_options = ChromeOptions()
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-setuid-sandbox")
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.headless = headless
        capabilities = {
            "browserName": "chrome",
            "version": "83.0",
            "platform": "LINUX"
        }
        if settings.DEBUG:
            driver = webdriver.Remote(
                command_executor='http://selenium:4444/wd/hub',
                desired_capabilities=capabilities
            )
        # driver = webdriver.Chrome(chrome_options=chrome_options, executable_path=chrome_path)
        if headless:
            print('start headless driver')
        return driver

    def get_all_attributies(self, element):
        return [(x['name'], x['value']) for x in element.get_property('attributes')]

    def is_input_submit(aself, attrs):
        return any([x for x in attrs if (x[0] == 'type') and (x[1] == 'submit')])

    def separate_text_and_submit_input(self, all_inputs_by_form):
        submit_buttons = list()

        other_inputs = list()

        for input in all_inputs_by_form:
            attrs = self.get_all_attributies(input)
            value = (input, input.get_attribute('outerHTML'))
            print(value)
            if self.is_input_submit(attrs):
                submit_buttons.append(value)
            else:
                other_inputs.append(value)

        return other_inputs, submit_buttons

    def page_has_alert(self, driver):
        has_xss = False
        try:
            WebDriverWait(driver, 2).until(EC.alert_is_present(),
                                           'Timed out waiting for PA creation confirmation popup to appear.')
            try:
                driver.switch_to.alert.accept()
                has_xss = True
                self.has_alert = True
            except EC.NoAlertPresentException:
                print('NoAlertPresentException')
                self.has_alert = False
                return has_xss

            print("alert accepted")
        except TimeoutException:
            self.has_alert = False
            print("TimeoutException")
            return has_xss
        time.sleep(1)
        return has_xss

    def get_host(self, url: str) -> str:
        start_index_value = '://'
        end_index_value = '/'

        start_index = url.index(start_index_value) + len(start_index_value)
        end_index = url[start_index:].index(end_index_value) + start_index

        return url[start_index:end_index]

    def fill_data(self, xss_list, sql_injection, idor_list):
        return [
            {
                'type': 'sql_injection',
                'data': [x for x in sql_injection if x is not None]
            },
            {
                'type': 'idor',
                'data': [x for x in idor_list if x is not None]
            },
            {
                'type': 'xss',
                'data': [x for x in xss_list if x is not None]
            }
        ]

    def find_vulnerability(self, depth):

        self.driver.get(self.url)
        self._load_site()
        xss_list = list()

        all_links_xpath = '//a'
        all_links_elements = self.driver.find_elements_by_xpath(all_links_xpath)
        host = self.get_host(self.url)

        all_links_by_host = [x for x in
                             [kk for kk in all_links_elements if kk.get_attribute('href') is not None]
                             if host in x.get_attribute('href') and not any(
                ext in x.get_attribute('href') for ext in ['pdf', 'docx', 'jpg'])]

        # import ipdb; ipdb.set_trace()
        # sql_injection = [scan_sql_injection(x.get_attribute('href')) for x in all_links_by_host]
        # payload = scan_sql_injection('http://local.oits.su/api/public/shit_api?user_id=301')
        # sql_injection.append(payload)
        # sick.append('p')

        all_form_elements = self.driver.find_elements_by_xpath('//form')

        all_inputs_by_form = [x.find_elements_by_xpath('./*') for x in all_form_elements]

        # print('i found all_inputs', all_inputs_by_form)

        skip_alert = False
        for all_inputs in all_inputs_by_form:
            # has_xss = False

            try:
                text_input, submit = self.separate_text_and_submit_input(all_inputs)
            except:
                print('text_input has changed')
                continue
            xss_injection = ['''<img src="noimage" onerror="alert('xss')">''', '''<script>alert('xss')</script>''']

            for injection in xss_injection:
                for input, href in text_input:
                    xss_data = href
                    if self.page_has_alert(self.driver):

                        print('add xss')
                        # import ipdb; ipdb.set_trace()
                        xss_list.append(xss_data)
                        skip_alert = True
                    else:
                        print('NO ALERT')
                        try:
                            shit = input.is_displayed()
                            if shit:
                                    input.click()
                                    time.sleep(0.3)
                                    input.send_keys(injection)
                                    print('input displayed')
                        except:
                            print('element cannot interact')
                            continue

                if skip_alert:
                    continue

                for sub, href in submit:
                    try:
                        sub.click()
                    except:
                        print('sub not click')
                        continue
                    # has_xss = self.page_has_alert(self.driver)
                # import ipdb; ipdb.set_trace()
                # if has_xss:
                #     xss_list.append(input.get_attribute('outerHTML'))
        # import ipdb; ipdb.set_trace()
        # print()
        self.driver.close()
        # data = self.fill_data(xss_list, sql_injection, [])
        data = self.fill_data(xss_list, [], [])
        return data

    def _load_site(self):
        time.sleep(3)
